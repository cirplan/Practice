### 36. 有效的数独

> 题目

判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。

数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。

上图是一个部分填充的有效的数独。

数独部分空格内已填入了数字，空白格用 '.' 表示。

示例 1:
```
输入:
[
  ["5","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: true
```

示例 2:
```
输入:
[
  ["8","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: false
```
解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。
     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。

说明:

一个有效的数独（部分已被填充）不一定是可解的。
只需要根据以上规则，验证已经填入的数字是否有效即可。
给定数独序列只包含数字 1-9 和字符 '.' 。
给定数独永远是 9x9 形式的。

> 思路

最简单的思路的是分别循环：判断行中没有重复的数字，判断列中没有重复的数字，判断 3 x 3 子数独没有重复的数字。

但能不能通过一次循环来实现呢？可以的，我们可以通过三个辅助 Map 来实现。

举例子：
```
[
  ["5","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
```

第0行0列5，记录 rowMap[05] = 1， colMap[05] = 1， sudokuMap[005] = 1

第0行1列3，记录 rowMap[03] = 1， colMap[13] = 1， sudokuMap[003] = 1

...

第i行j列N，记录 rowMap[i + N] = 1， colMap[j + N] = 1， sudokuMap[N/3 + M/3 + N] = 1

当下一项在 rowMap || colMap || sudokuMap 中存在时，表示这不是一个有效的数独

> 代码

```js
/**
 * @param {character[][]} board
 * @return {boolean}
 */
var isValidSudoku = function (board) {
  let rowMap = {};
  let colMap = {};
  let sudokuMap = {};

  for (let row = 0; row < 9; row++) {
    for (let col = 0; col < 9; col++) {
      const num = board[row][col];
      const rowKey = '' + row + num;
      const colKey = '' + col + num;
      const matrixKey =
        '' +
        parseInt(row / 3) +
        parseInt(col / 3) +
        num;
      if (num === '.') continue;
      else if (
        rowMap[rowKey] ||
        colMap[colKey] ||
        sudokuMap[matrixKey]
      ) {
        return false;
      } else {
        rowMap[rowKey] = 1;
        colMap[colKey] = 1;
        sudokuMap[matrixKey] = 1;
      }
    }
  }

  return true;
};
```

> 复杂度分析

时间复杂度：因为数独固定是9 x 9，循环一次，所以为O(1)。

空间复杂度：使用了额外的Map来记录，为O(1)。

> 执行

执行用时：96 ms, 在所有 JavaScript 提交中击败了69.25%的用户。

内存消耗：43.1 MB, 在所有 JavaScript 提交中击败了25.92%的用户。


